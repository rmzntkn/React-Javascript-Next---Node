"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.createSchemaCustomization = createSchemaCustomization;

var _lodash = _interopRequireDefault(require("lodash"));

var _fetch = require("./fetch");

var _pluginOptions = require("./plugin-options");

var _report = require("./report");

// @ts-check
async function getContentTypesFromContentFul({
  cache,
  reporter,
  pluginConfig
}) {
  // Get content type items from Contentful
  const contentTypeItems = await (0, _fetch.fetchContentTypes)({
    pluginConfig,
    reporter
  }); // Check for restricted content type names and set id based on useNameForId

  const useNameForId = pluginConfig.get(`useNameForId`);
  const restrictedContentTypes = [`entity`, `reference`, `asset`];

  if (pluginConfig.get(`enableTags`)) {
    restrictedContentTypes.push(`tags`);
  }

  contentTypeItems.forEach(contentTypeItem => {
    // Establish identifier for content type
    //  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
    //  but sometimes a base62 uuid generated by Contentful, hence the option)
    let contentTypeItemId;

    if (useNameForId) {
      contentTypeItemId = contentTypeItem.name.toLowerCase();
    } else {
      contentTypeItemId = contentTypeItem.sys.id.toLowerCase();
    }

    if (restrictedContentTypes.includes(contentTypeItemId)) {
      reporter.panic({
        id: _report.CODES.FetchContentTypes,
        context: {
          sourceMessage: `Restricted ContentType name found. The name "${contentTypeItemId}" is not allowed.`
        }
      });
    }
  }); // Store processed content types in cache for sourceNodes

  const sourceId = `${pluginConfig.get(`spaceId`)}-${pluginConfig.get(`environment`)}`;
  const CACHE_CONTENT_TYPES = `contentful-content-types-${sourceId}`;
  await cache.set(CACHE_CONTENT_TYPES, contentTypeItems);
  return contentTypeItems;
}

async function createSchemaCustomization({
  schema,
  actions,
  reporter,
  cache
}, pluginOptions) {
  const {
    createTypes
  } = actions;
  const pluginConfig = (0, _pluginOptions.createPluginConfig)(pluginOptions);
  let contentTypeItems;

  if (process.env.GATSBY_WORKER_ID) {
    const sourceId = `${pluginConfig.get(`spaceId`)}-${pluginConfig.get(`environment`)}`;
    contentTypeItems = await cache.get(`contentful-content-types-${sourceId}`);
  } else {
    contentTypeItems = await getContentTypesFromContentFul({
      cache,
      reporter,
      pluginConfig
    });
  }

  const contentfulTypes = [schema.buildInterfaceType({
    name: `ContentfulEntry`,
    fields: {
      contentful_id: {
        type: `String!`
      },
      id: {
        type: `ID!`
      },
      node_locale: {
        type: `String!`
      }
    },
    extensions: {
      infer: false
    },
    interfaces: [`Node`]
  }), schema.buildInterfaceType({
    name: `ContentfulReference`,
    fields: {
      contentful_id: {
        type: `String!`
      },
      id: {
        type: `ID!`
      }
    },
    extensions: {
      infer: false
    }
  }), schema.buildObjectType({
    name: `ContentfulAsset`,
    fields: {
      contentful_id: {
        type: `String!`
      },
      id: {
        type: `ID!`
      },
      ...(pluginConfig.get(`downloadLocal`) ? {
        localFile: {
          type: `File`,
          extensions: {
            link: {
              from: `fields.localFile`
            }
          }
        }
      } : {})
    },
    interfaces: [`ContentfulReference`, `Node`]
  })]; // Create types for each content type

  contentTypeItems.forEach(contentTypeItem => contentfulTypes.push(schema.buildObjectType({
    name: _lodash.default.upperFirst(_lodash.default.camelCase(`Contentful ${pluginConfig.get(`useNameForId`) ? contentTypeItem.name : contentTypeItem.sys.id}`)),
    fields: {
      contentful_id: {
        type: `String!`
      },
      id: {
        type: `ID!`
      },
      node_locale: {
        type: `String!`
      }
    },
    interfaces: [`ContentfulReference`, `ContentfulEntry`, `Node`]
  })));

  if (pluginConfig.get(`enableTags`)) {
    contentfulTypes.push(schema.buildObjectType({
      name: `ContentfulTag`,
      fields: {
        name: {
          type: `String!`
        },
        contentful_id: {
          type: `String!`
        },
        id: {
          type: `ID!`
        }
      },
      interfaces: [`Node`],
      extensions: {
        dontInfer: {}
      }
    }));
  }

  createTypes(contentfulTypes);
}